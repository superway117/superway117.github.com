[{"title":"mongoose findOneAndUpdate","date":"2017-03-15T01:09:44.000Z","path":"2017/03/15/findOneAndUpdate/","text":"mongoose findOneAndUpdate的用法 Mongoose supports this natively with findOneAndUpdate , it calls MongoDB findAndModify. 参数upsert if true, it creates the object if it doesn’t exist. defaults to false. new if true, returns the modified document rather than the original. The findAndModify() method ignores the new option for remove operations. The default is false. update 操作mongodb update $setOnInsert Sets the value of a field if an update results in an insert of a document. Has no effect on update operations that modify existing documents. 也就是说新增才会写 mongoose里面用setDefaultsOnInsert setDefaultsOnInsert: if this and upsert are true, mongoose will apply the defaults specified in the model’s schema if a new document is created. This option only works on MongoDB &gt;= 2.4 because it relies on MongoDB’s $setOnInsert operator. 如果要用这个选项的，需要的model的地方配置默认值 $set Sets the value of a field in a document. Sample1Model.findByIdAndUpdate(id, &#123; $set: &#123; name: &apos;jason borne&apos; &#125;&#125;, options, callback)","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://superway117.github.io/tags/MongoDB/"}]},{"title":"Adminlte Usage","date":"2017-03-08T01:40:09.000Z","path":"2017/03/08/adminlte-usage/","text":"sidebarsidebar-mini: sidebar只显示图片,不设置它，就是图片文字都显示 123&lt;body class=&quot;hold-transition skin-blue sidebar-mini&quot;&gt;&lt;/body&gt;` sidebar-collapse: sidebar初始是收缩状态 123&lt;body class=&quot;hold-transition skin-blue sidebar-collapse&quot;&gt;&lt;/body&gt;`","tags":[{"name":"前端","slug":"前端","permalink":"http://superway117.github.io/tags/前端/"}]},{"title":"如何在ng-repeat里面,每隔3个元素换行","date":"2017-03-02T04:27:14.000Z","path":"2017/03/02/angular_row_4/","text":"problem: 如何在ng-repeat里面,每隔3个元素换行 solution: 12345678&lt;div class=&quot;row&quot;&gt; &lt;div ng-repeat=&quot;product in products&quot;&gt; &lt;div class=&quot;clearfix&quot; ng-if=&quot;$index % 3 == 0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;h2&gt;&#123;&#123;product.title&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; referencestackoverflow","tags":[{"name":"前端","slug":"前端","permalink":"http://superway117.github.io/tags/前端/"}]},{"title":"flex-layout","date":"2017-02-23T15:40:49.000Z","path":"2017/02/23/flex_layout/","text":"referenceflexboxfroggy github game 阮一峰 Flex 布局教程：语法篇 Flex 布局教程：实例篇 demo 张鑫旭 CSS box-flex属性，然后弹性盒子模型简介 xiaoxiangzi CSS3 Flexbox可视化指南","tags":[{"name":"css","slug":"css","permalink":"http://superway117.github.io/tags/css/"}]},{"title":"Python numpy Index","date":"2017-01-16T02:32:09.000Z","path":"2017/01/16/py_numpy_index/","text":"In Python, x[(exp1, exp2, …, expN)] is equivalent to x[exp1, exp2, …, expN]; the latter is just syntactic sugar for the former. numpy.newaxis The newaxis object can be used in all slicing operations to create an axis of length one. :const: newaxis is an alias for ‘None’, and ‘None’ can be used in place of this with the same result. numpy.newaxis Basic Slicing and Indexing格式 Basic slicing occurs when obj is a slice object (constructed by start:stop:step notation inside of brackets), an integer, or a tuple of slice objects and integers. 也就是说slice,integer,tuple of slice objects and integers, 这样的index我们称为Basic Slicing Advanced Indexing","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python numpy shape","date":"2017-01-13T06:32:13.000Z","path":"2017/01/13/py_numpy_shape/","text":"123456789101112131415161718In [52]: x3 = np.random.randint(10, size=(3, 4, 5))In [53]: x3Out[53]:array([[[1, 7, 4, 7, 5], [3, 5, 9, 4, 3], [6, 9, 4, 1, 4], [2, 0, 8, 9, 4]], [[8, 6, 8, 7, 6], [1, 7, 8, 7, 1], [4, 8, 6, 5, 7], [9, 0, 2, 7, 9]], [[6, 6, 6, 2, 1], [6, 5, 7, 5, 9], [5, 0, 8, 8, 1], [4, 7, 0, 6, 1]]]) 1234567891011In [57]: x3.ndimOut[57]: 3In [58]: x3.shapeOut[58]: (3L, 4L, 5L)In [59]: x3.sizeOut[59]: 60In [61]: x3.stridesOut[61]: (80L, 20L, 4L) ndim : the number of dimensions,也就是维度, 上面的x3就是一个3维数组. shape: the size of each dimension, 可以认为是数组的形状,每一维的大小. size : total size of the array, 这个size是指元素的个数: 345==60 strides: 每个轴上面相邻元素的地址差. 上面的例子(80L, 20L, 4L), 其中80==20*4,最后一个轴的元素size就是4(int). numpy在数据存储上面支持C语言的方式:连续的内存存储空间,也支持Fortan的方式.默认是C语言. numpy.ndarray.flags 描述了数组的内存layout信息. 12345678In [63]: x3.flagsOut[63]: C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : True ALIGNED : True UPDATEIFCOPY : False C_CONTIGUOUS就是C语言的存储方式 F_CONTIGUOUS就是Fortan语言的存储方式 ALIGNED,C语言里面要内存对其，就存在padding的问题,这个true就表示完全follow C语言做内存对其 OWNDATA, 如果是view的话，这里就是false. reference numpy.ndarray.flags","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Sphinx","date":"2017-01-12T08:52:21.000Z","path":"2017/01/12/py_Sphinx/","text":"Sphinx是一个静态网站生成器,可以用来做静态网站或者写文档 Sphinx基于reStructuredText,markdown语法，配置文件就是py文件: conf.py Sphinx支持Python 2.6+, 3.3+. For full documentation visit sphinx-doc. Quick StartInstall 1pip install Sphinx Start a new project 1sphinx-quickstart 执行这个命令后，会step by step的生成一个工程,同时conf.py就生成了.同时根目录下面会生成一个make.bat文件（window下面)，后面我们就可以通过这个make.bat来生成页面或者发布了. make.bat支持多种格式，比如html,epub,json,latex,singlehtml. 支持列表可以敲入下面的命令查看. 1make.bat help 通过下面的命令生成网页 1make.bat html 这个命令等同于 1sphinx-build -b html sourcedir builddir Theme在conf.py修改theme 12345html_theme = &quot;classic&quot;html_theme_options = &#123; &quot;rightsidebar&quot;: &quot;true&quot;, &quot;relbarbgcolor&quot;: &quot;black&quot;&#125; 参考页面theming sphinx_rtd_themescrapy和readthedocs都是采用的sphinx_rtd_theme,效果参考scrapy doc页面或者readthedocs install 1pip install sphinx_rtd_theme usage 12345import sphinx_rtd_themehtml_theme = &quot;sphinx_rtd_theme&quot;html_theme_path = [sphinx_rtd_theme.get_html_theme_path()] 支持Markdown支持Markdown，简单说需要2步: 安装Markdown解析工具 1pip install recommonmark.parser 修改conf.py告诉sphinx支持Markdown 1234567from recommonmark.parser import CommonMarkParser默认只支持rst后缀文件source_suffix = &apos;.rst&apos; 改成source_parsers = &#123;&apos;.md&apos;: CommonMarkParser&#125; source_suffix = [&apos;.rst&apos;, &apos;.md&apos;] References scrapinghub scrapinghub 文档,rst格式 source link doc link readthedocs readthedocs 文档,rst格式 doc link scrapy scrapy 文档,rst格式 source link doc link","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python namedtuple","date":"2017-01-10T16:43:38.000Z","path":"2017/01/11/py_namedtuple/","text":"tuple只能用index来获取对应位置的值,也就是0,1,2,3 这种形式对代码可读性,可维护性都不是很好. 很多时候我们需要用类似dict的方式来取值. 这个时候就需要namedtuple namedtuple某种意义上就是一个文本的模板,帮助你定义一个tuple的子类. 1Point = namedtuple('Point', ['x', 'y'], verbose=True) 就相当于定义了一个类Point 下面的代码关键在于 __dict__ = _property(_asdict),他定义了一个dict,这样我们才可以实现用名字来获取值. 另外因为用到了__slots__,这个是为了节省memory, 所以大胆的用namedtuple,开销不是很大. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Point(tuple): 'Point(x, y)' __slots__ = () _fields = ('x', 'y') def __new__(_cls, x, y): 'Create new instance of Point(x, y)' return _tuple.__new__(_cls, (x, y)) @classmethod def _make(cls, iterable, new=tuple.__new__, len=len): 'Make a new Point object from a sequence or iterable' result = new(cls, iterable) if len(result) != 2: raise TypeError('Expected 2 arguments, got %d' % len(result)) return result def __repr__(self): 'Return a nicely formatted representation string' return 'Point(x=%r, y=%r)' % self def _asdict(self): 'Return a new OrderedDict which maps field names to their values' return OrderedDict(zip(self._fields, self)) def _replace(_self, **kwds): 'Return a new Point object replacing specified fields with new values' result = _self._make(map(kwds.pop, ('x', 'y'), _self)) if kwds: raise ValueError('Got unexpected field names: %r' % kwds.keys()) return result def __getnewargs__(self): 'Return self as a plain tuple. Used by copy and pickle.' return tuple(self) __dict__ = _property(_asdict) def __getstate__(self): 'Exclude the OrderedDict from pickling' pass x = _property(_itemgetter(0), doc='Alias for field number 0') y = _property(_itemgetter(1), doc='Alias for field number 1') usage123456789101112Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;], verbose=True)&gt;&gt;&gt; p = Point(11, y=22) # instantiate with positional or keyword arguments&gt;&gt;&gt; p[0] + p[1] # indexable like the plain tuple (11, 22)33&gt;&gt;&gt; x, y = p # unpack like a regular tuple&gt;&gt;&gt; x, y(11, 22)&gt;&gt;&gt; p.x + p.y # fields also accessible by name33&gt;&gt;&gt; p # readable __repr__ with a name=value stylePoint(x=11, y=22) 另外注意_fields的用法，他直接返回了原始的tuple reference collections.namedtuple Python cookbook 1.18. Mapping Names to Sequence Elements","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Private Variables","date":"2016-12-31T11:11:33.000Z","path":"2016/12/31/py_private_variables/","text":"Python是不支持Private关键字的.Python通过2种形式来支持private. 约定俗成如果一个成员是以一个下划线开头(有且只有一个),这种情况是python里面约定俗成的私有变量. 但是注意 python语法上没有对他做任何处理, 这只是一个编码习惯. 123456789101112class A: def __init__(self): self._internal = 0 # An internal attribute self.public = 1 # A public attribute def public_method(self): ''' A public method ''' ... def _internal_method(self): name mangling如果成员是以两个下划线开头,且结尾至多一个下划线,这种类成员python是会做一个重命名的, __spam,python会改出: _classname__spam. python设计这样的东西,是为了阻止继承的类oeverridden这样的属性. 下面是从python cookbook里面copy出来的. At this point, you might ask what purposesuch name mangling serves. The answer is inheritance—such attributes cannot beoverridden via inheritance 1234567891011121314151617181920class B: def __init__(self): self.__private = 0 --&gt;相当于__B_private def __private_method(self): def public_method(self): ... self.__private_method() --&gt;相当于__B_private_method ...class C(B): def __init__(self): super().__init__() self.__private = 1 # Does not override B.__private # Does not override B.__private_method() def __private_method(self): --&gt;相当于__C_private_method 下面是werkzeug\\local.py的code. 主要注意的是object.__setattr__用的是转换后的名字_LocalProxy__local 1object.__setattr__(self, '_LocalProxy__local', local) references Private Variables and Class-local References 关于Python的class的私有变量扎压 Python的命名机制 Python Cookbook 8.5. Encapsulating Names in a Class","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"hexo draft","date":"2016-12-29T08:10:57.000Z","path":"2016/12/29/hexo_draft/","text":"如果文章写了一半,想设置成draft怎么办? 看看source/_drafts存在否,不存在,创建一个 把相关文章xx.md和xx目录扔进去就行,是mv不是cp 直接创建一个draft1hexo new draft &quot;new draft&quot; 这个命令也就是相关文件创建在source/_drafts,默认是创建在source/_posts 强行显示draft__config.yml里面修改: 1render_drafts: true 或者启动server的时候加参数 1hexo server --drafts 发布draft下面的命令可以发布,未验证，事实上, publish我从来就没用过 1hexo publish [layout] &lt;filename&gt;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://superway117.github.io/tags/hexo/"}]},{"title":"Python descriptor","date":"2016-12-23T03:12:41.000Z","path":"2016/12/23/py_descriptor/","text":"descriptor应该算的上是python的黑魔法了,不了解这个东西,很多源码估计看的头晕脑胀的. Definition and IntroductionIn general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. Those methods are get(), set(), and delete(). If any of those methods are defined for an object, it is said to be a descriptor. 对属性的访问,通常是指set,get,delete操作, 比如 a.x,默认情况下,会follow下面的次序访问a.x: 查找 a.__dict__[&#39;x&#39;]是否存在，如果存在，直接返回，不存在下一步 查找 type(a).__dict__[&#39;x&#39;]是否存在，如果存在，直接返回，不存在下一步 查找 base classes of type(a) excluding metaclasses 上面的是默认的行为， 如果a.x,其中x是一个descriptor(只要定义了其中一个函数就算),走的就是另外的流程 Python may override the default behavior and invoke the descriptor method instead. Where this occurs in the precedence chain depends on which descriptor methods were defined. Note that descriptors are only invoked for new style objects or classes (a class is new style if it inherits from object or type). 需要注意的是descriptor必须继承object或者type Note that descriptors are only invoked for new style objects or classes (a class is new style if it inherits from object or type). Descriptors are a powerful, general purpose protocol. They are the mechanism behind properties, methods, static methods, class methods, and super(). They are used throughout Python itself to implement the new style classes introduced in version 2.2. Descriptors simplify the underlying C-code and offer a flexible set of new tools for everyday Python programs. Descriptor Protocol其实就3个函数,只要定义了下面的3个函数(至少一个),这个类就认为是descriptor 12345descr.__get__(self, obj, type=None) --&gt; valuedescr.__set__(self, obj, value) --&gt; Nonedescr.__delete__(self, obj) --&gt; None descriptor: 定义了protocol里面任意一个函数,就认为是一个descriptor data descriptor: 定义了get() and set(),就被认为是data descriptor read-only data descriptor: define both get() and set() with the set() raising an AttributeError when called non-data descriptors: only define get() are called non-data descriptors Invoking Descriptors如果obj.d, 其中d定义了 __get__. 那么可以直接调用__get__,虽然很少这么用.1d.__get__(obj) 大部分情况下这么用obj.d就可以了: obj.d looks up d in the dictionary of obj: obj.__dict__ 如果d定义了__get__(), then d.__get__(obj) is invoked according to the precedence rules listed below. For objects, the machinery is in object.getattribute() which transforms b.x into type(b).dict[‘x’].get(b, type(b)). The implementation works through a precedence chain that gives data descriptors priority over instance variables, instance variables priority over non-data descriptors, and assigns lowest priority to getattr() if provided. The full C implementation can be found in PyObject_GenericGetAttr() in Objects/object.c. For classes, the machinery is in type.__getattribute__() which transforms B.x into B.__dict__[&#39;x&#39;].__get__(None, B). In pure Python, it looks like: 123456def __getattribute__(self, key): \"Emulate type_getattro() in Objects/typeobject.c\" v = object.__getattribute__(self, key) if hasattr(v, '__get__'): return v.__get__(None, self) return v The important points to remember are: descriptors are invoked by the __getattribute__() method overriding __getattribute__() prevents automatic descriptor calls __getattribute__() is only available with new style classes and objects object.__getattribute__() and type.__getattribute__() make different calls to __get__(). data descriptors always override instance dictionaries. non-data descriptors may be overridden by instance dictionaries. Sample1234567891011121314151617181920212223242526272829303132class RevealAccess(object): \"\"\"A data descriptor that sets and returns values normally and prints a message logging their access. \"\"\" def __init__(self, initval=None, name='var'): self.val = initval self.name = name def __get__(self, obj, objtype): print 'Retrieving', self.name return self.val def __set__(self, obj, val): print 'Updating', self.name self.val = val&gt;&gt;&gt; class MyClass(object):... x = RevealAccess(10, 'var \"x\"')... y = 5...&gt;&gt;&gt; m = MyClass()&gt;&gt;&gt; m.xRetrieving var \"x\"10&gt;&gt;&gt; m.x = 20Updating var \"x\"&gt;&gt;&gt; m.xRetrieving var \"x\"20&gt;&gt;&gt; m.y5 Properties原来Property也是一个descriptor 123456789101112131415161718192021222324252627282930313233343536class Property(object): \"Emulate PyProperty_Type() in Objects/descrobject.c\" def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel if doc is None and fget is not None: doc = fget.__doc__ self.__doc__ = doc def __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError(\"unreadable attribute\") return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set attribute\") self.fset(obj, value) def __delete__(self, obj): if self.fdel is None: raise AttributeError(\"can't delete attribute\") self.fdel(obj) def getter(self, fget): return type(self)(fget, self.fset, self.fdel, self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__) references下面的这篇文档值得多看几次. Descriptor HowTo Guide","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python excepthook","date":"2016-12-22T20:58:10.000Z","path":"2016/12/23/py_excepthook/","text":"Python解释器默认定义了一个excepthook,发生异常退出的时候,会执行这个函数.然而我们可以重新定义这个hook函数,来实现更好的调试. 重新定义hook,也就是重新给sys.excepthook赋值. use case出现异常打开ipython从scrapy里面copy出来的, scrapy里面用下面的方式把ipython当做他的shell 1234567891011121314151617181920212223import systry: from IPython.terminal.embed import InteractiveShellEmbed from IPython.terminal.ipapp import load_default_configexcept ImportError: from IPython.frontend.terminal.embed import InteractiveShellEmbed from IPython.frontend.terminal.ipapp import load_default_configclass Hook: \"\"\"A hook to replace sys.excepthook that open ipython def __call__(self, etype, evalue, etb): self.handle((etype, evalue, etb)) def handle(self, info=None): config = load_default_config() shell = InteractiveShellEmbed() shell()handler = Hook().handledef enable() sys.excepthook = Hook() ultratb.ColorTB I’ve always found it a bit hard to visually parse tracebacks in Python. The ColorTB class is a solution to that problem. It colors the different parts of a traceback in a manner similar to what you would expect from a syntax-highlighting text editor. IPython.core.ultratb 12import sys,ultratbsys.excepthook = ultratb.ColorTB() ultratb.VerboseTB I’ve also included a port of Ka-Ping Yee’s “cgitb.py” that produces all kinds of useful info when a traceback occurs. Ping originally had it spit out HTML and intended it for CGI programmers, but why should they have all the fun? I altered it to spit out colored text to the terminal. It’s a bit overwhelming, but kind of neat, and maybe useful for long-running programs that you believe are bug-free. If a crash does occur in that type of program you want details. Give it a shot–you’ll love it or you’ll hate it. IPython.core.ultratb 12import sys,ultratbsys.excepthook = ultratb.VerboseTB() cgitb用来输出exception到html/text. 源码: Python-2.7.11\\Lib\\cgitb.py 12import cgitbcgitb.enable() enable可以带参数:1234display - if true, tracebacks are displayed in the web browserlogdir - if set, tracebacks are written to files in this directorycontext - number of lines of source code to show for each stack frameformat - &apos;text&apos; or &apos;html&apos; controls the output format enable原型 123456789def enable(display=1, logdir=None, context=5, format=\"html\"): \"\"\"Install an exception handler that formats tracebacks as HTML. The optional argument 'display' can be set to 0 to suppress sending the traceback to the browser, and 'logdir' can be set to a directory to cause tracebacks to be written to files there.\"\"\" sys.excepthook = Hook(display=display, logdir=logdir, context=context, format=format) 源码分析 Python-2.7.11\\Python\\pythonrun.c pythonrun.c 里面程序退出前,总是会调用下PyErr_Print 123456789101112voidPyErr_Print(void)&#123; PyErr_PrintEx(1);&#125;voidPyErr_PrintEx(int set_sys_last_vars)&#123; xxxx hook = PySys_GetObject(\"excepthook\"); if (hook &amp;&amp; hook != Py_None) &#123; PyObject *result = PyEval_CallObject(hook, args); 上面的代码简单的理解就是,从sys模块里面找到excepthook,然后执行他. python默认的excepthook实现在sys Python-2.7.11\\Python\\sysmodule.c 1234567891011static PyObject *sys_excepthook(PyObject* self, PyObject* args)&#123; PyObject *exc, *value, *tb; if (!PyArg_UnpackTuple(args, \"excepthook\", 3, 3, &amp;exc, &amp;value, &amp;tb)) return NULL; PyErr_Display(exc, value, tb); Py_INCREF(Py_None); return Py_None;&#125; 注册给sys是这样的: 12static PyMethodDef sys_methods[] = &#123; &#123;\"excepthook\", sys_excepthook, METH_VARARGS, excepthook_doc&#125;, sys模块初始化的时候把默认excepthook的定义,保存在__excepthook__ 123456PyObject *_PySys_Init(void)&#123; PyDict_SetItemString(sysdict, \"__excepthook__\", PyDict_GetItemString(sysdict, \"excepthook\"));&#125;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python __debug__&assert","date":"2016-12-22T05:24:31.000Z","path":"2016/12/22/py_debug/","text":"__debug__是python内置的变量,用来判断是否是调试模式. 我们开发过程中的debug代码,可以用它来控制. 默认情况下__debug__ == True 如果执行python的时候加上option -o/-oo,__debug__会被设置成False. 12-O : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x-OO : remove doc-strings in addition to the -O optimizations __debug__ cannot be reassigned(虽然文档里面2.7可以重新赋值,但是实际好像不行) 1234In [22]: __debug__=FalseFile &quot;&lt;ipython-input-22-b964276c1288&gt;&quot;, line 1 __debug__=FalseSyntaxError: cannot assign to __debug__ assertassert是一个用来调试的断言,他的执行是依赖__debug__ Assert statements are a convenient way to insert debugging assertions into a program:1assert_stmt ::= &quot;assert&quot; expression [&quot;,&quot; expression] 他等价于 12if __debug__: if not expression: raise AssertionError 也可以同时写多个表达式1assert expression1, expression2, 他等价于 12if __debug__: if not expression1: raise AssertionError(expression2) 常规用法 1assert buffer_size % 4 == 0, 'buffer size has to be divisible by 4' AssertionError Python-2.7.11\\Objects\\exceptions.c 123456789101112/* * StandardError extends Exception */SimpleExtendsException(PyExc_Exception, StandardError, &quot;Base class for all standard Python exceptions that do not represent\\n&quot; &quot;interpreter exiting.&quot;);/* * AssertionError extends StandardError */SimpleExtendsException(PyExc_StandardError, AssertionError, &quot;Assertion failed.&quot;);","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python property","date":"2016-12-21T16:49:22.000Z","path":"2016/12/22/py_property/","text":"property对应的是c代码的实现propertyobject. 主要是用来处理class里面的属性get/set/delete/doc操作. 需要注意的是应用property的class必须继承object,不然有问题,root cause未知. python cookbook里面的case有些是跑不起来的,就是因为他的代码很多没有继承object 主要的应用场景: set的时候做类型检查 get的时候做一些运算 禁止delete操作 实际python代码里面,可以继承property或者用property作为一个装饰器来用. 下面的写法是一致的. 可以理解是用来做装饰器. 123456789101112131415161718class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \\\"I'm the 'x' property.\\\")Decorators make defining new properties or modifying existing ones easy:class C(object): @property def x(self): \\\"I am the 'x' property.\\\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x use casecached_property代码从 werkzeug-master\\werkzeug\\utils.py copy出来的. 这段代码主要用来cache已经计算过的值. 需要注意的是 cached value 存在 obj.dict[self.name], self.name默认是函数名 c.area = 11 用来执行 cached_property.set ,给cached值重新赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import mathclass cached_property(property): \"\"\"A decorator that converts a function into a lazy property. The function wrapped is called the first time to retrieve the result and then that calculated result is used the next time you access the value:: class Foo(object): @cached_property def foo(self): # calculate something important here return 42 The class has to have a `__dict__` in order for this property to work. \"\"\" # implementation detail: A subclass of python's builtin property # decorator, we override __get__ to check for a cached value. If one # choses to invoke __get__ by hand the property will still work as # expected because the lookup logic is replicated in __get__ for # manual invocation. def __init__(self, func, name=None, doc=None): self.__name__ = name or func.__name__ self.__module__ = func.__module__ self.__doc__ = doc or func.__doc__ self.func = func def __set__(self, obj, value): print \"__set__ value:%d\" % (value,) obj.__dict__[self.__name__] = value def __get__(self, obj, type=None): if obj is None: return self value = obj.__dict__.get(self.__name__, None) if value is None: value = self.func(obj) obj.__dict__[self.__name__] = value return valueclass Circle(object): def __init__(self, radius): self.radius = radius @cached_property def area(self): print('Computing area') return math.pi * self.radius ** 2if __name__ == '__main__': c=Circle(2) print c.area print c.area c.area = 11 print c.area result 1234Computing area12.566370614412.566370614411 类型检查 setter里面做类型检查 deleter里面禁止删除动作 123456789101112131415161718192021222324252627282930class Person(object): def __init__(self, name): self.name = name # Getter function @property def name(self): print('get name in Person') return self._name # Setter function @name.setter def name(self, value): if not isinstance(value, str): raise TypeError('Expected a string') print('set name in Person') self._name = value # Deleter function @name.deleter def name(self): raise AttributeError(\"Can't delete attribute\")if __name__ == '__main__': s = Person('Guido') print s.name s.name = 'Larry' print s.name s.name = 42 print s.name result 123456789101112set name in Personget name in PersonGuidoset name in Personget name in PersonLarryTraceback (most recent call last): File &quot;test.py&quot;, line 45, in &lt;module&gt; s.name = 42 File &quot;test.py&quot;, line 15, in name raise TypeError(&apos;Expected a string&apos;)TypeError: Expected a string Extending a Property in a Subclass12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person(object): def __init__(self, name): self.name = name # Getter function @property def name(self): print('get name in Person') return self._name # Setter function @name.setter def name(self, value): if not isinstance(value, str): raise TypeError('Expected a string') print('set name in Person') self._name = value # Deleter function @name.deleter def name(self): raise AttributeError(\"Can't delete attribute\")class SubPerson(Person): @property def name(self): print('get name in SubPerson') return super(SubPerson, self).name @name.setter def name(self, value): print('set name in SubPerson') super(SubPerson, SubPerson).name.__set__(self, value) @name.deleter def name(self): print('Deleting name') super(SubPerson, SubPerson).name.__delete__(self)if __name__ == '__main__': s = SubPerson('Guido') print s.name s.name = 'Larry' print s.name s.name = 42 print s.name result 12345678910111213141516171819set name in SubPersonset name in Personget name in SubPersonget name in PersonGuidoset name in SubPersonset name in Personget name in SubPersonget name in PersonLarryset name in SubPersonTraceback (most recent call last): File &quot;test.py&quot;, line 45, in &lt;module&gt; s.name = 42 File &quot;test.py&quot;, line 33, in name super(SubPerson, SubPerson).name.__set__(self, va File &quot;test.py&quot;, line 15, in name raise TypeError(&apos;Expected a string&apos;)TypeError: Expected a string 源码分析 Python-2.7.11\\Objects\\descrobject.c 疑问super的用法,还真是有点疑惑","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python PyIntObject","date":"2016-12-19T16:09:10.000Z","path":"2016/12/20/py_intobject/","text":"PyIntObject属于固定size的object,所以数据结构也比较简单. 1234typedef struct &#123; PyObject_HEAD long ob_ival;&#125; PyIntObject; 本文topic主要在PyIntObject如何实现内存/性能优化. 概括的说 对于small int, 默认是-5–257之间的PyIntObject,是预分配的, 每次只要从small_ints这个池子里面去就行 预先分配了一个pool(free_list),2.7定义的是(1000-8)个PyIntObject,每次需要分配PyIntObject,直接从free_list取 源码分析_PyInt_InitPython解释器执行的时候会做一个动作. 12Py_InitializeEx --&gt;_PyInt_Init 所有的逻辑看_PyInt_Init就清楚了. 12345678910111213141516171819int_PyInt_Init(void)&#123; PyIntObject *v; int ival;#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0 for (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++) &#123; if (!free_list &amp;&amp; (free_list = fill_free_list()) == NULL) return 0; /* PyObject_New is inlined */ v = free_list; free_list = (PyIntObject *)Py_TYPE(v); PyObject_INIT(v, &amp;PyInt_Type); v-&gt;ob_ival = ival; small_ints[ival + NSMALLNEGINTS] = v; &#125;#endif return 1;&#125; 上面的逻辑: 1234567for(ival=-5; ival&lt;257; ival++)&#123; 1. 从free_list里面去一个空闲的 PyIntObject --&gt;v 2. 给v赋值 ob_ival = ival 3. free_list里面ob_type用来指向前一个block,所有这里需要做一个PyObject_INIT 4. 因为是从-5开始算起，所有small_ints[0]是给-5用的,以此类推&#125; free_list只分配一次12if (!free_list &amp;&amp; (free_list = fill_free_list()) == NULL) return 0; free_listfill_free_list的逻辑就是一次申请 N_INTOBJECTS 个 PyIntObject. 1PyMem_MALLOC(sizeof(PyIntBlock)) 需要注意的是: fill_free_list返回的是最后一个block: p + N_INTOBJECTS - 1 每一个block的ob_type,用来指向前一个block 第一个block的ob_type是null,这个用来判断当前free_list是否已经用完了 block_list用来维护多个free_list 123456789101112131415161718192021222324252627282930struct _intblock &#123; struct _intblock *next; PyIntObject objects[N_INTOBJECTS];&#125;;typedef struct _intblock PyIntBlock;static PyIntBlock *block_list = NULL;static PyIntObject *free_list = NULL;static PyIntObject *fill_free_list(void)&#123; PyIntObject *p, *q; /* Python's object allocator isn't appropriate for large blocks. */ p = (PyIntObject *) PyMem_MALLOC(sizeof(PyIntBlock)); if (p == NULL) return (PyIntObject *) PyErr_NoMemory(); ((PyIntBlock *)p)-&gt;next = block_list; block_list = (PyIntBlock *)p; /* Link the int objects together, from rear to front, then return the address of the last int object in the block. */ p = &amp;((PyIntBlock *)p)-&gt;objects[0]; q = p + N_INTOBJECTS; while (--q &gt; p) Py_TYPE(q) = (struct _typeobject *)(q-1); Py_TYPE(q) = NULL; return p + N_INTOBJECTS - 1;&#125;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python PyStringObject","date":"2016-12-19T16:09:10.000Z","path":"2016/12/20/py_stringobject/","text":"PyStringObject属于变长size的object 12345678910111213141516171819typedef struct &#123; PyObject_VAR_HEAD long ob_shash; int ob_sstate; char ob_sval[1]; /* Invariants: * ob_sval contains space for 'ob_size+1' elements. * ob_sval[ob_size] == 0. * ob_shash is the hash of the string or -1 if not computed yet. * ob_sstate != 0 iff the string object is in stringobject.c's * 'interned' dictionary; in this case the two references * from 'interned' to this object are *not counted* in ob_refcnt. */&#125; PyStringObject;#define PyObject_VAR_HEAD \\ PyObject_HEAD \\ Py_ssize_t ob_size; /* Number of items in variable part */ ob_size存的是字符串的size,strlen(str),不包含结束符 针对size=0 or 1的字符串内存优化看PyString_FromStringAndSize的实现 如果size==0, 返回null_strings,引用计数+1 如果size==1，如果characters数组里面已经存在,直接返回,引用计数+1;如果characters数组里面不存在,创建一个，并保存在characters数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657PyObject *PyString_FromStringAndSize(const char *str, Py_ssize_t size)&#123; register PyStringObject *op; if (size &lt; 0) &#123; PyErr_SetString(PyExc_SystemError, \"Negative size passed to PyString_FromStringAndSize\"); return NULL; &#125; if (size == 0 &amp;&amp; (op = nullstring) != NULL) &#123;#ifdef COUNT_ALLOCS null_strings++;#endif Py_INCREF(op); return (PyObject *)op; &#125; if (size == 1 &amp;&amp; str != NULL &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) &#123;#ifdef COUNT_ALLOCS one_strings++;#endif Py_INCREF(op); return (PyObject *)op; &#125; if (size &gt; PY_SSIZE_T_MAX - PyStringObject_SIZE) &#123; PyErr_SetString(PyExc_OverflowError, \"string is too large\"); return NULL; &#125; /* Inline PyObject_NewVar */ op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size); if (op == NULL) return PyErr_NoMemory(); PyObject_INIT_VAR(op, &amp;PyString_Type, size); op-&gt;ob_shash = -1; op-&gt;ob_sstate = SSTATE_NOT_INTERNED; if (str != NULL) Py_MEMCPY(op-&gt;ob_sval, str, size); op-&gt;ob_sval[size] = '\\0'; /* share short strings */ if (size == 0) &#123; PyObject *t = (PyObject *)op; PyString_InternInPlace(&amp;t); op = (PyStringObject *)t; nullstring = op; Py_INCREF(op); &#125; else if (size == 1 &amp;&amp; str != NULL) &#123; PyObject *t = (PyObject *)op; PyString_InternInPlace(&amp;t); op = (PyStringObject *)t; characters[*str &amp; UCHAR_MAX] = op; Py_INCREF(op); &#125; return (PyObject *) op;&#125;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Decorator - 理解调用过程","date":"2016-12-15T06:54:30.000Z","path":"2016/12/15/py_decorator_2/","text":"主要topic Decorator是怎么调用的 用partial来实现一个带参数的Decorator Decorator的调用理解Decorator的第一步要理解Decorator是怎么调用的. 下面的例子是Decorator不带参数的情况 123@logged()def add(x, y): return x+y 他相当于 1234def add(x, y): return x + yadd = logged(add) 下面的例子是Decorator带参数的情况123@logged(level=logging.CRITICAL, name='example')def spam(): print('Spam!') 他相当于 123def spam(): print('Spam!')spam = logged(level=logging.CRITICAL, name='example')(spam) 用partial实现带参数的Decorator下面的 logged demo了,怎么样实现兼容一个带或者不带参数的Decorator 关键的地方是: 理解如何调用 1234567891011121314151617from functools import wraps, partialimport loggingdef logged(func=None, *, level=logging.DEBUG, name=None, message=None): if func is None: return partial(logged, level=level, name=name, message=message) logname = name if name else func.__module__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args, **kwargs): log.log(level, logmsg) return func(*args, **kwargs) return wrapper Example use 1234567@loggeddef add(x, y): return x + y@logged(level=logging.CRITICAL, name=&apos;example&apos;)def spam(): print(&apos;Spam!&apos;) 不带参数的情况123@loggeddef add(x, y): return x + y 等价1234def add(x, y): return x + yadd = logged(add) logged里面针对这个情况,返回的是wrapper,注意, 这个wrapper是被@wraps(func)包装过的. 相当于 1add = logged(add) == wraps(add)(wrapper) wraps的实现如下: 12345678910111213141516171819202122232425262728293031323334353637WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')WRAPPER_UPDATES = ('__dict__',)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) \"\"\" for attr in assigned: setattr(wrapper, attr, getattr(wrapped, attr)) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;)) # Return the wrapper so this can be used as a decorator via partial() return wrapperdef wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). \"\"\" return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) 所以1234567add = logged(add) == wraps(add)(wrapper)==&gt;1. wraps(add) 返回一个 partialobject 实例(pto),他封装的函数是 update_wrapper2. wraps(add)(wrapper) 相当于执行 partial_call partial_call --&gt; ret = PyObject_Call(pto-&gt;fn, argappl, kwappl) --&gt; update_wrapper() --&gt; update_wrapper() --&gt; return add 这样绕了一圈 add 终于还是等于 add 了 带参数的情况123@logged(level=logging.CRITICAL, name='example')def spam(): print('Spam!') 相当于 123456789add = logged(level=logging.CRITICAL, name='example')(add) == partial(logged,xxx)(add)partial 封装的是logged, 参数:level=logging.CRITICAL, name='example'也被带入partial--&gt;partial_new(logged,level=logging.CRITICAL, name='example')partial(logged,xxx)(add) 调用 partial_call--&gt;partial_call(add)--&gt;logged(add,level=logging.CRITICAL, name='example')不过这里有个疑问是,logged 怎么指定 func==add?, add是作为PyTuple传入的,不是PyDict","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Decorator - 理解partial","date":"2016-12-12T15:42:20.000Z","path":"2016/12/12/py_decorator_1/","text":"主要topic是partial的源码实现 什么是partialpartial 是functools里面的一个函数对象,虽然用起来就是一个函数. 它是一个decorator function,也就是说用来decorator其他函数的. 比如decorator add函数，它的第一个参数必须是一个函数,后面的参数,在真正执行add的时候，会带入到add里面,作为add的参数. 123456789101112131415161718In [9]: from functools import partialIn [10]: def add(a,b):....: return a+b....:In [11]: add(4,3)Out[11]: 7In [12]: plus = partial(add,100)In [13]: plus(9)Out[13]: 109In [14]: plus2 = partial(add,99)In [15]: plus2(9)Out[15]: 108 源码分析打开python 2.7的源码,partial是用C语言实现的,对应的源码在 Python-2.7.11\\Modules\\_functoolsmodule.c 主要3个函数： partial_new: 执行plus = partial(add,100),会创建一个partialobject对象 partial_dealloc: 释放partialobject对象 partial_call: 执行plus(9),会调用到这个函数 partial_setstate: 这个用来替换前面传入的add,以及参数, 一般情况很少用 下面的这些函数,一般情况是用不上. partial_traverse partial_get_dict partial_set_dict partial_new 创建partialobject对象 args是一个PyTuple,第一个参数必须是一个PyCallable，简单的说就是一个函数对象 1func = PyTuple_GET_ITEM(args, 0); args其他的参数会保存为 pto-&gt;args 1pto-&gt;args = PyTuple_GetSlice(args, 1, PY_SSIZE_T_MAX); kw如果存在会被复制一份 1pto-&gt;kw = (kw != NULL) ? PyDict_Copy(kw) : PyDict_New(); dict默认是null, 后面可以通过partial_set_dict来设置 1pto-&gt;dict = NULL; source code1234567891011121314151617181920212223242526272829303132333435363738394041424344static PyObject *partial_new(PyTypeObject *type, PyObject *args, PyObject *kw)&#123; PyObject *func; partialobject *pto; if (PyTuple_GET_SIZE(args) &lt; 1) &#123; PyErr_SetString(PyExc_TypeError, \"type 'partial' takes at least one argument\"); return NULL; &#125; func = PyTuple_GET_ITEM(args, 0); if (!PyCallable_Check(func)) &#123; PyErr_SetString(PyExc_TypeError, \"the first argument must be callable\"); return NULL; &#125; /* create partialobject structure */ pto = (partialobject *)type-&gt;tp_alloc(type, 0); if (pto == NULL) return NULL; pto-&gt;fn = func; Py_INCREF(func); pto-&gt;args = PyTuple_GetSlice(args, 1, PY_SSIZE_T_MAX); if (pto-&gt;args == NULL) &#123; pto-&gt;kw = NULL; Py_DECREF(pto); return NULL; &#125; pto-&gt;kw = (kw != NULL) ? PyDict_Copy(kw) : PyDict_New(); if (pto-&gt;kw == NULL) &#123; Py_DECREF(pto); return NULL; &#125; pto-&gt;weakreflist = NULL; pto-&gt;dict = NULL; return (PyObject *)pto;&#125; partial_deallocnew创建的所有对象的引用计数全部dec一下 partial_call 执行plus(9),会调用到这个函数 args会做一次合并,如果都不为空的话 1argappl = PySequence_Concat(pto-&gt;args, args); kw会做一次合并,如果都不为空的话 1if (PyDict_Merge(kwappl, kw, 1) != 0) 基本上看到这里,大概能理解partial的作用了. source code123456789101112131415161718192021222324252627282930313233343536373839404142434445static PyObject *partial_call(partialobject *pto, PyObject *args, PyObject *kw)&#123; PyObject *ret; PyObject *argappl = NULL, *kwappl = NULL; assert (PyCallable_Check(pto-&gt;fn)); assert (PyTuple_Check(pto-&gt;args)); assert (pto-&gt;kw == Py_None || PyDict_Check(pto-&gt;kw)); if (PyTuple_GET_SIZE(pto-&gt;args) == 0) &#123; argappl = args; Py_INCREF(args); &#125; else if (PyTuple_GET_SIZE(args) == 0) &#123; argappl = pto-&gt;args; Py_INCREF(pto-&gt;args); &#125; else &#123; argappl = PySequence_Concat(pto-&gt;args, args); if (argappl == NULL) return NULL; &#125; if (pto-&gt;kw == Py_None) &#123; kwappl = kw; Py_XINCREF(kw); &#125; else &#123; kwappl = PyDict_Copy(pto-&gt;kw); if (kwappl == NULL) &#123; Py_DECREF(argappl); return NULL; &#125; if (kw != NULL) &#123; if (PyDict_Merge(kwappl, kw, 1) != 0) &#123; Py_DECREF(argappl); Py_DECREF(kwappl); return NULL; &#125; &#125; &#125; ret = PyObject_Call(pto-&gt;fn, argappl, kwappl); Py_DECREF(argappl); Py_XDECREF(kwappl); return ret;&#125; partial的帮手从source code里面copy出来的注释: update_wrapper() and wraps() are tools to help write wrapper functions that can handle naive introspection 简单的说,decorator function会导致被 decorator的函数,原有的module,name,doc丢失. update_wrapper() and wraps()就是为了解决这个问题存在的. 所以一般来说,还是多用wraps比较好,他会保留原函数的信息. 但是wraps有一个限制，用了这个函数，第一个参数是函数对象, 后面没机会他给传其他参数了.也就是说，只能传被wrapper的函数,后面调用的时候自己传了. partial就没用这个限制. Usage下面是一个例子,用wraps来实现怎么打印一个函数的时间消耗. 123456789101112131415import timefrom functools import wrapsdef timethis(func): ''' Decorator that reports the execution time. ''' @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper Here is an example of using the decorator: 12345678910111213&gt;&gt;&gt; @timethis... def countdown(n):... '''... Counts down... '''... while n &gt; 0:... n -= 1...&gt;&gt;&gt; countdown(100000)countdown 0.008917808532714844&gt;&gt;&gt; countdown(10000000)countdown 0.87188299392912&gt;&gt;&gt; 前面提到wraps,只能 源码分析代码行比较少,就是给新函数重新赋值原函数的信息. 12345678910111213141516171819202122232425262728293031323334353637WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')WRAPPER_UPDATES = ('__dict__',)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) \"\"\" for attr in assigned: setattr(wrapper, attr, getattr(wrapped, attr)) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;)) # Return the wrapper so this can be used as a decorator via partial() return wrapperdef wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). \"\"\" return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) Notescopy from python cookbook Last, but not least, be aware that not all decorators utilize @wraps, and thus, they may not work as described. In particular, the built-in decorators @staticmethod and @class method create descriptor objects that don’t follow this convention (instead, they store the original function in a func attribute). Your mileage may vary.","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Package管理","date":"2016-12-09T04:49:52.000Z","path":"2016/12/09/py_package_import/","text":"init.pymodule(包括sub module)目录下面, 在py2.7上面,这个文件是需要的;在3.x上面,这个文件已经不是必须的. __init__是会被在module(submodule)加载之前加载 . __init__可以用来实现下面的功能: 帮用户加载需要的submodule或者符号 123# graphics/formats/__init__.pyfrom . import jpgfrom . import png 这样的话用户只需要下面的语句,就可以得到需要的符号 1import graphics.formats 如何控制 export symbolProblem下面的语句会导致把module里面的所有符号都导出. 1from module import * 这样的做法是不受鼓励的,但是事实上为了方便,我们经常这么干. 从性能或者从安全的角度出发,很多时候我们要控制export的符号 Solution__all__ 可以帮你控制输出的符号 demo123456789# somemodule.pydef spam(): passdef grok(): passblah = 42# Only export 'spam' and 'grok'__all__ = ['spam', 'grok'] 如果你定义了__all__为一个空数组,那么nothing will be exported. AttributeError is raised on import if all contains undefined names. Namespace Packages“namespace package” Essentially, a namespace package is a special kind of package designed for merging different directories of code together under a common namespace links Implicit Namespace Packages","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Thread Local","date":"2016-12-06T16:54:05.000Z","path":"2016/12/07/py_thread_local/","text":"Problem如何实现: 保存线程自己的值或者状态,并且这个值对其他线程是不可见 Solutionthread-local storage object 可以用来满足这个需求,thread-local只有当前的线程可见. Sample Code下面的code demo了怎么样使用 thread-local 123456789101112131415161718192021222324252627282930313233343536373839404142from socket import socket, AF_INET, SOCK_STREAMimport threadingfrom functools import partialclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = AF_INET self.type = SOCK_STREAM self.local = threading.local() print \"__init__\" def __enter__(self): print \"__enter__\" if hasattr(self.local, 'sock'): raise RuntimeError('Already connected') self.local.sock = socket(self.family, self.type) self.local.sock.connect(self.address) return self.local.sock def __exit__(self, exc_ty, exc_val, tb): print \"__exit__\" self.local.sock.close() del self.local.sockdef test(conn): with conn as s: s.send(b'GET /index.html HTTP/1.0\\r\\n') s.send(b'Host: www.python.org\\r\\n') s.send(b'\\r\\n') resp = b''.join(iter(partial(s.recv, 8192), b'')) print('Got &#123;&#125; bytes'.format(len(resp)))if __name__ == '__main__': conn = LazyConnection(('www.python.org', 80)) t1 = threading.Thread(target=test, args=(conn,)) t2 = threading.Thread(target=test, args=(conn,)) t1.start() t2.start() t1.join() t2.join() 打印的结果 1234567__init____enter____enter__Got 795 bytes__exit__Got 795 bytes__exit__ 源码分析打开python 2.7的源码,thread local 对应的源码在 Python-2.7.11\\Lib\\_threading_local.py thread local 就是下面的继承关系 1object &gt; _localbase &gt; local 如何实现线程独立拥有自己的local仔细看上面的code, LazyConnection 只实例化了一次,也就是说__init__只调用了一次,所以conn对各个线程来说是共享的,为什么下面的 socket 赋值可以做到各个线程拥有独立的sock对象? 1self.local.sock = socket(self.family, self.type) 虽然new 一个 local 实例, 这个实例对于所有线程是共享的,但是真正执行set/get操作的实现在 _patch,这个函数是关键. 12345678910111213141516def _patch(self): key = object.__getattribute__(self, '_local__key') d = current_thread().__dict__.get(key) if d is None: d = &#123;&#125; current_thread().__dict__[key] = d object.__setattr__(self, '__dict__', d) # we have a new instance dict, so call out __init__ if we have # one cls = type(self) if cls.__init__ is not object.__init__: args, kw = object.__getattribute__(self, '_local__args') cls.__init__(self, *args, **kw) else: object.__setattr__(self, '__dict__', d) 先看 if d is not None 的case 1object.__setattr__(self, '__dict__', d) 也就是说 每次set/get的时候，上面这句话改变了 __dict__,他把 current_thread().__dict__.get(key) 赋值给了__dict__, 而对object的set/get 操作，实际也就是对 __dict__的操作. 如何实现lock因为每次都要改变local.dict,必然存在一个问题,就是要锁操作. 下面的代码会构造一个RLock 给 local, 注意,这个rlock是给local的,也就是说所有线程都是用这个rlock来执行锁操作的. 1234567891011121314151617181920class _localbase(object): __slots__ = '_local__key', '_local__args', '_local__lock' def __new__(cls, *args, **kw): self = object.__new__(cls) key = '_local__key', 'thread.local.' + str(id(self)) object.__setattr__(self, '_local__key', key) object.__setattr__(self, '_local__args', (args, kw)) object.__setattr__(self, '_local__lock', RLock()) if (args or kw) and (cls.__init__ is object.__init__): raise TypeError(\"Initialization arguments are not supported\") # We need to create the thread dict in anticipation of # __init__ being called, to make sure we don't call it # again ourselves. dict = object.__getattribute__(self, '__dict__') current_thread().__dict__[key] = dict return self 看下local get操作 ,进入之前acquire,finally 保证了释放 12345678def __getattribute__(self, name): lock = object.__getattribute__(self, '_local__lock') lock.acquire() try: _patch(self) return object.__getattribute__(self, name) finally: lock.release() __slots___localbase 用 __slots__ 来限制 local的 instance variables __slots__ 的解释: copy from python org The __slots__ declaration takes a list of instance variables, and reserves space in the instance for exactly these in the instance. When __slots__ is used, other instance variables cannot be assigned to 123456class defaultdict2(dict): __slots__ = ['default'] def __init__(self, default=None): ...(like before)... 1234567891011&gt;&gt;&gt; a = defaultdict2(default=0.0)&gt;&gt;&gt; a[1]0.0&gt;&gt;&gt; a.default = -1&gt;&gt;&gt; a[1]-1&gt;&gt;&gt; a.x1 = 1Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in ?AttributeError: 'defaultdict2' object has no attribute 'x1'&gt;&gt;&gt;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Hexo Usage","date":"2016-12-06T00:54:05.000Z","path":"2016/12/06/hexo_usage/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://superway117.github.io/tags/hexo/"}]}]