[{"title":"Python partial","date":"2016-12-12T15:42:20.000Z","path":"2016/12/12/py_partial/","text":"什么是partialpartial 是functools里面的一个函数对象,虽然用起来就是一个函数. 它是一个decorator function,也就是说用来decorator其他函数的. 比如decorator add函数，它的第一个参数必须是一个函数,后面的参数,在真正执行add的时候，会带入到add里面,作为add的参数. 123456789101112131415161718In [9]: from functools import partialIn [10]: def add(a,b):....: return a+b....:In [11]: add(4,3)Out[11]: 7In [12]: plus = partial(add,100)In [13]: plus(9)Out[13]: 109In [14]: plus2 = partial(add,99)In [15]: plus2(9)Out[15]: 108 源码分析打开python 2.7的源码,partial是用C语言实现的,对应的源码在 Python-2.7.11\\Modules\\_functoolsmodule.c 主要3个函数： partial_new: 执行plus = partial(add,100),会创建一个partialobject对象 partial_dealloc: 释放partialobject对象 partial_call: 执行plus(9),会调用到这个函数 partial_setstate: 这个用来替换前面传入的add,以及参数, 一般情况很少用 下面的这些函数,一般情况是用不上. partial_traverse partial_get_dict partial_set_dict partial_new 创建partialobject对象 args是一个PyTuple,第一个参数必须是一个PyCallable，简单的说就是一个函数对象 1func = PyTuple_GET_ITEM(args, 0); args其他的参数会保存为 pto-&gt;args 1pto-&gt;args = PyTuple_GetSlice(args, 1, PY_SSIZE_T_MAX); kw如果存在会被复制一份 1pto-&gt;kw = (kw != NULL) ? PyDict_Copy(kw) : PyDict_New(); dict默认是null, 后面可以通过partial_set_dict来设置 1pto-&gt;dict = NULL; source code1234567891011121314151617181920212223242526272829303132333435363738394041424344static PyObject *partial_new(PyTypeObject *type, PyObject *args, PyObject *kw)&#123; PyObject *func; partialobject *pto; if (PyTuple_GET_SIZE(args) &lt; 1) &#123; PyErr_SetString(PyExc_TypeError, \"type 'partial' takes at least one argument\"); return NULL; &#125; func = PyTuple_GET_ITEM(args, 0); if (!PyCallable_Check(func)) &#123; PyErr_SetString(PyExc_TypeError, \"the first argument must be callable\"); return NULL; &#125; /* create partialobject structure */ pto = (partialobject *)type-&gt;tp_alloc(type, 0); if (pto == NULL) return NULL; pto-&gt;fn = func; Py_INCREF(func); pto-&gt;args = PyTuple_GetSlice(args, 1, PY_SSIZE_T_MAX); if (pto-&gt;args == NULL) &#123; pto-&gt;kw = NULL; Py_DECREF(pto); return NULL; &#125; pto-&gt;kw = (kw != NULL) ? PyDict_Copy(kw) : PyDict_New(); if (pto-&gt;kw == NULL) &#123; Py_DECREF(pto); return NULL; &#125; pto-&gt;weakreflist = NULL; pto-&gt;dict = NULL; return (PyObject *)pto;&#125; partial_deallocnew创建的所有对象的引用计数全部dec一下 partial_call 执行plus(9),会调用到这个函数 args会做一次合并,如果都不为空的话 1argappl = PySequence_Concat(pto-&gt;args, args); kw会做一次合并,如果都不为空的话 1if (PyDict_Merge(kwappl, kw, 1) != 0) 基本上看到这里,大概能理解partial的作用了. source code123456789101112131415161718192021222324252627282930313233343536373839404142434445static PyObject *partial_call(partialobject *pto, PyObject *args, PyObject *kw)&#123; PyObject *ret; PyObject *argappl = NULL, *kwappl = NULL; assert (PyCallable_Check(pto-&gt;fn)); assert (PyTuple_Check(pto-&gt;args)); assert (pto-&gt;kw == Py_None || PyDict_Check(pto-&gt;kw)); if (PyTuple_GET_SIZE(pto-&gt;args) == 0) &#123; argappl = args; Py_INCREF(args); &#125; else if (PyTuple_GET_SIZE(args) == 0) &#123; argappl = pto-&gt;args; Py_INCREF(pto-&gt;args); &#125; else &#123; argappl = PySequence_Concat(pto-&gt;args, args); if (argappl == NULL) return NULL; &#125; if (pto-&gt;kw == Py_None) &#123; kwappl = kw; Py_XINCREF(kw); &#125; else &#123; kwappl = PyDict_Copy(pto-&gt;kw); if (kwappl == NULL) &#123; Py_DECREF(argappl); return NULL; &#125; if (kw != NULL) &#123; if (PyDict_Merge(kwappl, kw, 1) != 0) &#123; Py_DECREF(argappl); Py_DECREF(kwappl); return NULL; &#125; &#125; &#125; ret = PyObject_Call(pto-&gt;fn, argappl, kwappl); Py_DECREF(argappl); Py_XDECREF(kwappl); return ret;&#125; partial的帮手从source code里面copy出来的注释: update_wrapper() and wraps() are tools to help write wrapper functions that can handle naive introspection 简单的说,decorator function会导致被 decorator的函数,原有的module,name,doc丢失. update_wrapper() and wraps()就是为了解决这个问题存在的. 所以一般来说,还是多用wraps比较好,他会保留原函数的信息. 但是wraps有一个限制，用了这个函数，第一个参数是函数对象, 后面没机会他给传其他参数了.也就是说，只能传被wrapper的函数,后面调用的时候自己传了. partial就没用这个限制. Usage下面是一个例子,用wraps来实现怎么打印一个函数的时间消耗. 123456789101112131415import timefrom functools import wrapsdef timethis(func): ''' Decorator that reports the execution time. ''' @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper Here is an example of using the decorator: 12345678910111213&gt;&gt;&gt; @timethis... def countdown(n):... '''... Counts down... '''... while n &gt; 0:... n -= 1...&gt;&gt;&gt; countdown(100000)countdown 0.008917808532714844&gt;&gt;&gt; countdown(10000000)countdown 0.87188299392912&gt;&gt;&gt; 前面提到wraps,只能 源码分析代码行比较少,就是给新函数重新赋值原函数的信息. 12345678910111213141516171819202122232425262728293031323334353637WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')WRAPPER_UPDATES = ('__dict__',)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) \"\"\" for attr in assigned: setattr(wrapper, attr, getattr(wrapped, attr)) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;)) # Return the wrapper so this can be used as a decorator via partial() return wrapperdef wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). \"\"\" return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) Notescopy from python cookbook Last, but not least, be aware that not all decorators utilize @wraps, and thus, they may not work as described. In particular, the built-in decorators @staticmethod and @class method create descriptor objects that don’t follow this convention (instead, they store the original function in a func attribute). Your mileage may vary.","tags":[]},{"title":"Python Package管理","date":"2016-12-09T04:49:52.000Z","path":"2016/12/09/python_package_import/","text":"init.pymodule(包括sub module)目录下面, 在py2.7上面,这个文件是需要的;在3.x上面,这个文件已经不是必须的. __init__是会被在module(submodule)加载之前加载 . __init__可以用来实现下面的功能: 帮用户加载需要的submodule或者符号 123# graphics/formats/__init__.pyfrom . import jpgfrom . import png 这样的话用户只需要下面的语句,就可以得到需要的符号 1import graphics.formats 如何控制 export symbolProblem下面的语句会导致把module里面的所有符号都导出. 1from module import * 这样的做法是不受鼓励的,但是事实上为了方便,我们经常这么干. 从性能或者从安全的角度出发,很多时候我们要控制export的符号 Solution__all__ 可以帮你控制输出的符号 demo123456789# somemodule.pydef spam(): passdef grok(): passblah = 42# Only export 'spam' and 'grok'__all__ = ['spam', 'grok'] 如果你定义了__all__为一个空数组,那么nothing will be exported. AttributeError is raised on import if all contains undefined names. Namespace Packages“namespace package” Essentially, a namespace package is a special kind of package designed for merging different directories of code together under a common namespace links Implicit Namespace Packages","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Thread Local","date":"2016-12-06T16:54:05.000Z","path":"2016/12/07/py_thread_local/","text":"Problem如何实现: 保存线程自己的值或者状态,并且这个值对其他线程是不可见 Solutionthread-local storage object 可以用来满足这个需求,thread-local只有当前的线程可见. Sample Code下面的code demo了怎么样使用 thread-local 123456789101112131415161718192021222324252627282930313233343536373839404142from socket import socket, AF_INET, SOCK_STREAMimport threadingfrom functools import partialclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = AF_INET self.type = SOCK_STREAM self.local = threading.local() print \"__init__\" def __enter__(self): print \"__enter__\" if hasattr(self.local, 'sock'): raise RuntimeError('Already connected') self.local.sock = socket(self.family, self.type) self.local.sock.connect(self.address) return self.local.sock def __exit__(self, exc_ty, exc_val, tb): print \"__exit__\" self.local.sock.close() del self.local.sockdef test(conn): with conn as s: s.send(b'GET /index.html HTTP/1.0\\r\\n') s.send(b'Host: www.python.org\\r\\n') s.send(b'\\r\\n') resp = b''.join(iter(partial(s.recv, 8192), b'')) print('Got &#123;&#125; bytes'.format(len(resp)))if __name__ == '__main__': conn = LazyConnection(('www.python.org', 80)) t1 = threading.Thread(target=test, args=(conn,)) t2 = threading.Thread(target=test, args=(conn,)) t1.start() t2.start() t1.join() t2.join() 打印的结果 1234567__init____enter____enter__Got 795 bytes__exit__Got 795 bytes__exit__ 源码分析打开python 2.7的源码,thread local 对应的源码在 Python-2.7.11\\Lib\\_threading_local.py thread local 就是下面的继承关系 1object &gt; _localbase &gt; local 如何实现线程独立拥有自己的local仔细看上面的code, LazyConnection 只实例化了一次,也就是说__init__只调用了一次,所以conn对各个线程来说是共享的,为什么下面的 socket 赋值可以做到各个线程拥有独立的sock对象? 1self.local.sock = socket(self.family, self.type) 虽然new 一个 local 实例, 这个实例对于所有线程是共享的,但是真正执行set/get操作的实现在 _patch,这个函数是关键. 12345678910111213141516def _patch(self): key = object.__getattribute__(self, '_local__key') d = current_thread().__dict__.get(key) if d is None: d = &#123;&#125; current_thread().__dict__[key] = d object.__setattr__(self, '__dict__', d) # we have a new instance dict, so call out __init__ if we have # one cls = type(self) if cls.__init__ is not object.__init__: args, kw = object.__getattribute__(self, '_local__args') cls.__init__(self, *args, **kw) else: object.__setattr__(self, '__dict__', d) 先看 if d is not None 的case 1object.__setattr__(self, '__dict__', d) 也就是说 每次set/get的时候，上面这句话改变了 __dict__,他把 current_thread().__dict__.get(key) 赋值给了__dict__, 而对object的set/get 操作，实际也就是对 __dict__的操作. 如何实现lock因为每次都要改变local.dict,必然存在一个问题,就是要锁操作. 下面的代码会构造一个RLock 给 local, 注意,这个rlock是给local的,也就是说所有线程都是用这个rlock来执行锁操作的. 1234567891011121314151617181920class _localbase(object): __slots__ = '_local__key', '_local__args', '_local__lock' def __new__(cls, *args, **kw): self = object.__new__(cls) key = '_local__key', 'thread.local.' + str(id(self)) object.__setattr__(self, '_local__key', key) object.__setattr__(self, '_local__args', (args, kw)) object.__setattr__(self, '_local__lock', RLock()) if (args or kw) and (cls.__init__ is object.__init__): raise TypeError(\"Initialization arguments are not supported\") # We need to create the thread dict in anticipation of # __init__ being called, to make sure we don't call it # again ourselves. dict = object.__getattribute__(self, '__dict__') current_thread().__dict__[key] = dict return self 看下local get操作 ,进入之前acquire,finally 保证了释放 12345678def __getattribute__(self, name): lock = object.__getattribute__(self, '_local__lock') lock.acquire() try: _patch(self) return object.__getattribute__(self, name) finally: lock.release() __slots___localbase 用 __slots__ 来限制 local的 instance variables __slots__ 的解释: copy from python org The __slots__ declaration takes a list of instance variables, and reserves space in the instance for exactly these in the instance. When __slots__ is used, other instance variables cannot be assigned to 123456class defaultdict2(dict): __slots__ = ['default'] def __init__(self, default=None): ...(like before)... 1234567891011&gt;&gt;&gt; a = defaultdict2(default=0.0)&gt;&gt;&gt; a[1]0.0&gt;&gt;&gt; a.default = -1&gt;&gt;&gt; a[1]-1&gt;&gt;&gt; a.x1 = 1Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in ?AttributeError: 'defaultdict2' object has no attribute 'x1'&gt;&gt;&gt;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Hexo Usage","date":"2016-12-06T00:54:05.000Z","path":"2016/12/06/hexo_usage/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://superway117.github.io/tags/hexo/"}]}]