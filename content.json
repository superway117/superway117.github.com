[{"title":"Python __debug__&assert","date":"2016-12-22T05:24:31.000Z","path":"2016/12/22/python_debug/","text":"debug是python内置的变量,用来判断是否是调试模式. 我们开发过程中的debug代码,可以用它来控制. 默认情况下__debug__ == True 如果执行python的时候加上option -o/-oo,__debug__会被设置成False. 12-O : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x-OO : remove doc-strings in addition to the -O optimizations __debug__ cannot be reassigned(虽然文档里面2.7可以重新赋值,但是实际好像不行) 1234In [22]: __debug__=FalseFile &quot;&lt;ipython-input-22-b964276c1288&gt;&quot;, line 1 __debug__=FalseSyntaxError: cannot assign to __debug__ assertassert是一个用来调试的断言,他的执行是依赖__debug__ Assert statements are a convenient way to insert debugging assertions into a program:1assert_stmt ::= &quot;assert&quot; expression [&quot;,&quot; expression] 他等价于 12if __debug__: if not expression: raise AssertionError 也可以同时写多个表达式1assert expression1, expression2, 他等价于 12if __debug__: if not expression1: raise AssertionError(expression2) 常规用法 1assert buffer_size % 4 == 0, 'buffer size has to be divisible by 4' AssertionError Python-2.7.11\\Objects\\exceptions.c 123456789101112/* * StandardError extends Exception */SimpleExtendsException(PyExc_Exception, StandardError, &quot;Base class for all standard Python exceptions that do not represent\\n&quot; &quot;interpreter exiting.&quot;);/* * AssertionError extends StandardError */SimpleExtendsException(PyExc_StandardError, AssertionError, &quot;Assertion failed.&quot;);","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python property","date":"2016-12-21T16:49:22.000Z","path":"2016/12/22/py_property/","text":"property对应的是c代码的实现propertyobject. 主要是用来处理class里面的属性get/set/delete/doc操作. 需要注意的是应用property的class必须继承object,不然有问题,root cause未知. python cookbook里面的case有些是跑不起来的,就是因为他的代码很多没有继承object 主要的应用场景: set的时候做类型检查 get的时候做一些运算 禁止delete操作 实际python代码里面,可以继承property或者用property作为一个装饰器来用. 下面的写法是一致的. 可以理解是用来做装饰器. 123456789101112131415161718class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \\\"I'm the 'x' property.\\\")Decorators make defining new properties or modifying existing ones easy:class C(object): @property def x(self): \\\"I am the 'x' property.\\\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x use casecached_property代码从 werkzeug-master\\werkzeug\\utils.py copy出来的. 这段代码主要用来cache已经计算过的值. 需要注意的是 cached value 存在 obj.dict[self.name], self.name默认是函数名 c.area = 11 用来执行 cached_property.set ,给cached值重新赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import mathclass cached_property(property): \"\"\"A decorator that converts a function into a lazy property. The function wrapped is called the first time to retrieve the result and then that calculated result is used the next time you access the value:: class Foo(object): @cached_property def foo(self): # calculate something important here return 42 The class has to have a `__dict__` in order for this property to work. \"\"\" # implementation detail: A subclass of python's builtin property # decorator, we override __get__ to check for a cached value. If one # choses to invoke __get__ by hand the property will still work as # expected because the lookup logic is replicated in __get__ for # manual invocation. def __init__(self, func, name=None, doc=None): self.__name__ = name or func.__name__ self.__module__ = func.__module__ self.__doc__ = doc or func.__doc__ self.func = func def __set__(self, obj, value): print \"__set__ value:%d\" % (value,) obj.__dict__[self.__name__] = value def __get__(self, obj, type=None): if obj is None: return self value = obj.__dict__.get(self.__name__, None) if value is None: value = self.func(obj) obj.__dict__[self.__name__] = value return valueclass Circle(object): def __init__(self, radius): self.radius = radius @cached_property def area(self): print('Computing area') return math.pi * self.radius ** 2if __name__ == '__main__': c=Circle(2) print c.area print c.area c.area = 11 print c.area result 1234Computing area12.566370614412.566370614411 类型检查 setter里面做类型检查 deleter里面禁止删除动作 123456789101112131415161718192021222324252627282930class Person(object): def __init__(self, name): self.name = name # Getter function @property def name(self): print('get name in Person') return self._name # Setter function @name.setter def name(self, value): if not isinstance(value, str): raise TypeError('Expected a string') print('set name in Person') self._name = value # Deleter function @name.deleter def name(self): raise AttributeError(\"Can't delete attribute\")if __name__ == '__main__': s = Person('Guido') print s.name s.name = 'Larry' print s.name s.name = 42 print s.name result 123456789101112set name in Personget name in PersonGuidoset name in Personget name in PersonLarryTraceback (most recent call last): File &quot;test.py&quot;, line 45, in &lt;module&gt; s.name = 42 File &quot;test.py&quot;, line 15, in name raise TypeError(&apos;Expected a string&apos;)TypeError: Expected a string Extending a Property in a Subclass12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person(object): def __init__(self, name): self.name = name # Getter function @property def name(self): print('get name in Person') return self._name # Setter function @name.setter def name(self, value): if not isinstance(value, str): raise TypeError('Expected a string') print('set name in Person') self._name = value # Deleter function @name.deleter def name(self): raise AttributeError(\"Can't delete attribute\")class SubPerson(Person): @property def name(self): print('get name in SubPerson') return super(SubPerson, self).name @name.setter def name(self, value): print('set name in SubPerson') super(SubPerson, SubPerson).name.__set__(self, value) @name.deleter def name(self): print('Deleting name') super(SubPerson, SubPerson).name.__delete__(self)if __name__ == '__main__': s = SubPerson('Guido') print s.name s.name = 'Larry' print s.name s.name = 42 print s.name result 12345678910111213141516171819set name in SubPersonset name in Personget name in SubPersonget name in PersonGuidoset name in SubPersonset name in Personget name in SubPersonget name in PersonLarryset name in SubPersonTraceback (most recent call last): File &quot;test.py&quot;, line 45, in &lt;module&gt; s.name = 42 File &quot;test.py&quot;, line 33, in name super(SubPerson, SubPerson).name.__set__(self, va File &quot;test.py&quot;, line 15, in name raise TypeError(&apos;Expected a string&apos;)TypeError: Expected a string 源码分析 Python-2.7.11\\Objects\\descrobject.c 疑问super的用法,还真是有点疑惑","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python PyIntObject","date":"2016-12-19T16:09:10.000Z","path":"2016/12/20/py_intobject/","text":"PyIntObject属于固定size的object,所以数据结构也比较简单. 1234typedef struct &#123; PyObject_HEAD long ob_ival;&#125; PyIntObject; 本文topic主要在PyIntObject如何实现内存/性能优化. 概括的说 对于small int, 默认是-5–257之间的PyIntObject,是预分配的, 每次只要从small_ints这个池子里面去就行 预先分配了一个pool(free_list),2.7定义的是(1000-8)个PyIntObject,每次需要分配PyIntObject,直接从free_list取 源码分析_PyInt_InitPython解释器执行的时候会做一个动作. 12Py_InitializeEx --&gt;_PyInt_Init 所有的逻辑看_PyInt_Init就清楚了. 12345678910111213141516171819int_PyInt_Init(void)&#123; PyIntObject *v; int ival;#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0 for (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++) &#123; if (!free_list &amp;&amp; (free_list = fill_free_list()) == NULL) return 0; /* PyObject_New is inlined */ v = free_list; free_list = (PyIntObject *)Py_TYPE(v); PyObject_INIT(v, &amp;PyInt_Type); v-&gt;ob_ival = ival; small_ints[ival + NSMALLNEGINTS] = v; &#125;#endif return 1;&#125; 上面的逻辑: 1234567for(ival=-5; ival&lt;257; ival++)&#123; 1. 从free_list里面去一个空闲的 PyIntObject --&gt;v 2. 给v赋值 ob_ival = ival 3. free_list里面ob_type用来指向前一个block,所有这里需要做一个PyObject_INIT 4. 因为是从-5开始算起，所有small_ints[0]是给-5用的,以此类推&#125; free_list只分配一次12if (!free_list &amp;&amp; (free_list = fill_free_list()) == NULL) return 0; free_listfill_free_list的逻辑就是一次申请 N_INTOBJECTS 个 PyIntObject. 1PyMem_MALLOC(sizeof(PyIntBlock)) 需要注意的是: fill_free_list返回的是最后一个block: p + N_INTOBJECTS - 1 每一个block的ob_type,用来指向前一个block 第一个block的ob_type是null,这个用来判断当前free_list是否已经用完了 block_list用来维护多个free_list 123456789101112131415161718192021222324252627282930struct _intblock &#123; struct _intblock *next; PyIntObject objects[N_INTOBJECTS];&#125;;typedef struct _intblock PyIntBlock;static PyIntBlock *block_list = NULL;static PyIntObject *free_list = NULL;static PyIntObject *fill_free_list(void)&#123; PyIntObject *p, *q; /* Python's object allocator isn't appropriate for large blocks. */ p = (PyIntObject *) PyMem_MALLOC(sizeof(PyIntBlock)); if (p == NULL) return (PyIntObject *) PyErr_NoMemory(); ((PyIntBlock *)p)-&gt;next = block_list; block_list = (PyIntBlock *)p; /* Link the int objects together, from rear to front, then return the address of the last int object in the block. */ p = &amp;((PyIntBlock *)p)-&gt;objects[0]; q = p + N_INTOBJECTS; while (--q &gt; p) Py_TYPE(q) = (struct _typeobject *)(q-1); Py_TYPE(q) = NULL; return p + N_INTOBJECTS - 1;&#125;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python PyStringObject","date":"2016-12-19T16:09:10.000Z","path":"2016/12/20/py_stringobject/","text":"PyStringObject属于变长size的object 12345678910111213141516171819typedef struct &#123; PyObject_VAR_HEAD long ob_shash; int ob_sstate; char ob_sval[1]; /* Invariants: * ob_sval contains space for 'ob_size+1' elements. * ob_sval[ob_size] == 0. * ob_shash is the hash of the string or -1 if not computed yet. * ob_sstate != 0 iff the string object is in stringobject.c's * 'interned' dictionary; in this case the two references * from 'interned' to this object are *not counted* in ob_refcnt. */&#125; PyStringObject;#define PyObject_VAR_HEAD \\ PyObject_HEAD \\ Py_ssize_t ob_size; /* Number of items in variable part */ ob_size存的是字符串的size,strlen(str),不包含结束符 针对size=0 or 1的字符串内存优化看PyString_FromStringAndSize的实现 如果size==0, 返回null_strings,引用计数+1 如果size==1，如果characters数组里面已经存在,直接返回,引用计数+1;如果characters数组里面不存在,创建一个，并保存在characters数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657PyObject *PyString_FromStringAndSize(const char *str, Py_ssize_t size)&#123; register PyStringObject *op; if (size &lt; 0) &#123; PyErr_SetString(PyExc_SystemError, \"Negative size passed to PyString_FromStringAndSize\"); return NULL; &#125; if (size == 0 &amp;&amp; (op = nullstring) != NULL) &#123;#ifdef COUNT_ALLOCS null_strings++;#endif Py_INCREF(op); return (PyObject *)op; &#125; if (size == 1 &amp;&amp; str != NULL &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) &#123;#ifdef COUNT_ALLOCS one_strings++;#endif Py_INCREF(op); return (PyObject *)op; &#125; if (size &gt; PY_SSIZE_T_MAX - PyStringObject_SIZE) &#123; PyErr_SetString(PyExc_OverflowError, \"string is too large\"); return NULL; &#125; /* Inline PyObject_NewVar */ op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size); if (op == NULL) return PyErr_NoMemory(); PyObject_INIT_VAR(op, &amp;PyString_Type, size); op-&gt;ob_shash = -1; op-&gt;ob_sstate = SSTATE_NOT_INTERNED; if (str != NULL) Py_MEMCPY(op-&gt;ob_sval, str, size); op-&gt;ob_sval[size] = '\\0'; /* share short strings */ if (size == 0) &#123; PyObject *t = (PyObject *)op; PyString_InternInPlace(&amp;t); op = (PyStringObject *)t; nullstring = op; Py_INCREF(op); &#125; else if (size == 1 &amp;&amp; str != NULL) &#123; PyObject *t = (PyObject *)op; PyString_InternInPlace(&amp;t); op = (PyStringObject *)t; characters[*str &amp; UCHAR_MAX] = op; Py_INCREF(op); &#125; return (PyObject *) op;&#125;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Decorator - 理解调用过程","date":"2016-12-15T06:54:30.000Z","path":"2016/12/15/py_decorator_2/","text":"主要topic Decorator是怎么调用的 用partial来实现一个带参数的Decorator Decorator的调用理解Decorator的第一步要理解Decorator是怎么调用的. 下面的例子是Decorator不带参数的情况 123@logged()def add(x, y): return x+y 他相当于 1234def add(x, y): return x + yadd = logged(add) 下面的例子是Decorator带参数的情况123@logged(level=logging.CRITICAL, name='example')def spam(): print('Spam!') 他相当于 123def spam(): print('Spam!')spam = logged(level=logging.CRITICAL, name='example')(spam) 用partial实现带参数的Decorator下面的 logged demo了,怎么样实现兼容一个带或者不带参数的Decorator 关键的地方是: 理解如何调用 1234567891011121314151617from functools import wraps, partialimport loggingdef logged(func=None, *, level=logging.DEBUG, name=None, message=None): if func is None: return partial(logged, level=level, name=name, message=message) logname = name if name else func.__module__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args, **kwargs): log.log(level, logmsg) return func(*args, **kwargs) return wrapper Example use 1234567@loggeddef add(x, y): return x + y@logged(level=logging.CRITICAL, name=&apos;example&apos;)def spam(): print(&apos;Spam!&apos;) 不带参数的情况123@loggeddef add(x, y): return x + y 等价1234def add(x, y): return x + yadd = logged(add) logged里面针对这个情况,返回的是wrapper,注意, 这个wrapper是被@wraps(func)包装过的. 相当于 1add = logged(add) == wraps(add)(wrapper) wraps的实现如下: 12345678910111213141516171819202122232425262728293031323334353637WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')WRAPPER_UPDATES = ('__dict__',)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) \"\"\" for attr in assigned: setattr(wrapper, attr, getattr(wrapped, attr)) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;)) # Return the wrapper so this can be used as a decorator via partial() return wrapperdef wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). \"\"\" return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) 所以1234567add = logged(add) == wraps(add)(wrapper)==&gt;1. wraps(add) 返回一个 partialobject 实例(pto),他封装的函数是 update_wrapper2. wraps(add)(wrapper) 相当于执行 partial_call partial_call --&gt; ret = PyObject_Call(pto-&gt;fn, argappl, kwappl) --&gt; update_wrapper() --&gt; update_wrapper() --&gt; return add 这样绕了一圈 add 终于还是等于 add 了 带参数的情况123@logged(level=logging.CRITICAL, name='example')def spam(): print('Spam!') 相当于 123456789add = logged(level=logging.CRITICAL, name='example')(add) == partial(logged,xxx)(add)partial 封装的是logged, 参数:level=logging.CRITICAL, name='example'也被带入partial--&gt;partial_new(logged,level=logging.CRITICAL, name='example')partial(logged,xxx)(add) 调用 partial_call--&gt;partial_call(add)--&gt;logged(add,level=logging.CRITICAL, name='example')不过这里有个疑问是,logged 怎么指定 func==add?, add是作为PyTuple传入的,不是PyDict","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Decorator - 理解partial","date":"2016-12-12T15:42:20.000Z","path":"2016/12/12/py_decorator_1/","text":"主要topic是partial的源码实现 什么是partialpartial 是functools里面的一个函数对象,虽然用起来就是一个函数. 它是一个decorator function,也就是说用来decorator其他函数的. 比如decorator add函数，它的第一个参数必须是一个函数,后面的参数,在真正执行add的时候，会带入到add里面,作为add的参数. 123456789101112131415161718In [9]: from functools import partialIn [10]: def add(a,b):....: return a+b....:In [11]: add(4,3)Out[11]: 7In [12]: plus = partial(add,100)In [13]: plus(9)Out[13]: 109In [14]: plus2 = partial(add,99)In [15]: plus2(9)Out[15]: 108 源码分析打开python 2.7的源码,partial是用C语言实现的,对应的源码在 Python-2.7.11\\Modules\\_functoolsmodule.c 主要3个函数： partial_new: 执行plus = partial(add,100),会创建一个partialobject对象 partial_dealloc: 释放partialobject对象 partial_call: 执行plus(9),会调用到这个函数 partial_setstate: 这个用来替换前面传入的add,以及参数, 一般情况很少用 下面的这些函数,一般情况是用不上. partial_traverse partial_get_dict partial_set_dict partial_new 创建partialobject对象 args是一个PyTuple,第一个参数必须是一个PyCallable，简单的说就是一个函数对象 1func = PyTuple_GET_ITEM(args, 0); args其他的参数会保存为 pto-&gt;args 1pto-&gt;args = PyTuple_GetSlice(args, 1, PY_SSIZE_T_MAX); kw如果存在会被复制一份 1pto-&gt;kw = (kw != NULL) ? PyDict_Copy(kw) : PyDict_New(); dict默认是null, 后面可以通过partial_set_dict来设置 1pto-&gt;dict = NULL; source code1234567891011121314151617181920212223242526272829303132333435363738394041424344static PyObject *partial_new(PyTypeObject *type, PyObject *args, PyObject *kw)&#123; PyObject *func; partialobject *pto; if (PyTuple_GET_SIZE(args) &lt; 1) &#123; PyErr_SetString(PyExc_TypeError, \"type 'partial' takes at least one argument\"); return NULL; &#125; func = PyTuple_GET_ITEM(args, 0); if (!PyCallable_Check(func)) &#123; PyErr_SetString(PyExc_TypeError, \"the first argument must be callable\"); return NULL; &#125; /* create partialobject structure */ pto = (partialobject *)type-&gt;tp_alloc(type, 0); if (pto == NULL) return NULL; pto-&gt;fn = func; Py_INCREF(func); pto-&gt;args = PyTuple_GetSlice(args, 1, PY_SSIZE_T_MAX); if (pto-&gt;args == NULL) &#123; pto-&gt;kw = NULL; Py_DECREF(pto); return NULL; &#125; pto-&gt;kw = (kw != NULL) ? PyDict_Copy(kw) : PyDict_New(); if (pto-&gt;kw == NULL) &#123; Py_DECREF(pto); return NULL; &#125; pto-&gt;weakreflist = NULL; pto-&gt;dict = NULL; return (PyObject *)pto;&#125; partial_deallocnew创建的所有对象的引用计数全部dec一下 partial_call 执行plus(9),会调用到这个函数 args会做一次合并,如果都不为空的话 1argappl = PySequence_Concat(pto-&gt;args, args); kw会做一次合并,如果都不为空的话 1if (PyDict_Merge(kwappl, kw, 1) != 0) 基本上看到这里,大概能理解partial的作用了. source code123456789101112131415161718192021222324252627282930313233343536373839404142434445static PyObject *partial_call(partialobject *pto, PyObject *args, PyObject *kw)&#123; PyObject *ret; PyObject *argappl = NULL, *kwappl = NULL; assert (PyCallable_Check(pto-&gt;fn)); assert (PyTuple_Check(pto-&gt;args)); assert (pto-&gt;kw == Py_None || PyDict_Check(pto-&gt;kw)); if (PyTuple_GET_SIZE(pto-&gt;args) == 0) &#123; argappl = args; Py_INCREF(args); &#125; else if (PyTuple_GET_SIZE(args) == 0) &#123; argappl = pto-&gt;args; Py_INCREF(pto-&gt;args); &#125; else &#123; argappl = PySequence_Concat(pto-&gt;args, args); if (argappl == NULL) return NULL; &#125; if (pto-&gt;kw == Py_None) &#123; kwappl = kw; Py_XINCREF(kw); &#125; else &#123; kwappl = PyDict_Copy(pto-&gt;kw); if (kwappl == NULL) &#123; Py_DECREF(argappl); return NULL; &#125; if (kw != NULL) &#123; if (PyDict_Merge(kwappl, kw, 1) != 0) &#123; Py_DECREF(argappl); Py_DECREF(kwappl); return NULL; &#125; &#125; &#125; ret = PyObject_Call(pto-&gt;fn, argappl, kwappl); Py_DECREF(argappl); Py_XDECREF(kwappl); return ret;&#125; partial的帮手从source code里面copy出来的注释: update_wrapper() and wraps() are tools to help write wrapper functions that can handle naive introspection 简单的说,decorator function会导致被 decorator的函数,原有的module,name,doc丢失. update_wrapper() and wraps()就是为了解决这个问题存在的. 所以一般来说,还是多用wraps比较好,他会保留原函数的信息. 但是wraps有一个限制，用了这个函数，第一个参数是函数对象, 后面没机会他给传其他参数了.也就是说，只能传被wrapper的函数,后面调用的时候自己传了. partial就没用这个限制. Usage下面是一个例子,用wraps来实现怎么打印一个函数的时间消耗. 123456789101112131415import timefrom functools import wrapsdef timethis(func): ''' Decorator that reports the execution time. ''' @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper Here is an example of using the decorator: 12345678910111213&gt;&gt;&gt; @timethis... def countdown(n):... '''... Counts down... '''... while n &gt; 0:... n -= 1...&gt;&gt;&gt; countdown(100000)countdown 0.008917808532714844&gt;&gt;&gt; countdown(10000000)countdown 0.87188299392912&gt;&gt;&gt; 前面提到wraps,只能 源码分析代码行比较少,就是给新函数重新赋值原函数的信息. 12345678910111213141516171819202122232425262728293031323334353637WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')WRAPPER_UPDATES = ('__dict__',)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) \"\"\" for attr in assigned: setattr(wrapper, attr, getattr(wrapped, attr)) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;)) # Return the wrapper so this can be used as a decorator via partial() return wrapperdef wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). \"\"\" return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) Notescopy from python cookbook Last, but not least, be aware that not all decorators utilize @wraps, and thus, they may not work as described. In particular, the built-in decorators @staticmethod and @class method create descriptor objects that don’t follow this convention (instead, they store the original function in a func attribute). Your mileage may vary.","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Package管理","date":"2016-12-09T04:49:52.000Z","path":"2016/12/09/py_package_import/","text":"init.pymodule(包括sub module)目录下面, 在py2.7上面,这个文件是需要的;在3.x上面,这个文件已经不是必须的. __init__是会被在module(submodule)加载之前加载 . __init__可以用来实现下面的功能: 帮用户加载需要的submodule或者符号 123# graphics/formats/__init__.pyfrom . import jpgfrom . import png 这样的话用户只需要下面的语句,就可以得到需要的符号 1import graphics.formats 如何控制 export symbolProblem下面的语句会导致把module里面的所有符号都导出. 1from module import * 这样的做法是不受鼓励的,但是事实上为了方便,我们经常这么干. 从性能或者从安全的角度出发,很多时候我们要控制export的符号 Solution__all__ 可以帮你控制输出的符号 demo123456789# somemodule.pydef spam(): passdef grok(): passblah = 42# Only export 'spam' and 'grok'__all__ = ['spam', 'grok'] 如果你定义了__all__为一个空数组,那么nothing will be exported. AttributeError is raised on import if all contains undefined names. Namespace Packages“namespace package” Essentially, a namespace package is a special kind of package designed for merging different directories of code together under a common namespace links Implicit Namespace Packages","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Thread Local","date":"2016-12-06T16:54:05.000Z","path":"2016/12/07/py_thread_local/","text":"Problem如何实现: 保存线程自己的值或者状态,并且这个值对其他线程是不可见 Solutionthread-local storage object 可以用来满足这个需求,thread-local只有当前的线程可见. Sample Code下面的code demo了怎么样使用 thread-local 123456789101112131415161718192021222324252627282930313233343536373839404142from socket import socket, AF_INET, SOCK_STREAMimport threadingfrom functools import partialclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = AF_INET self.type = SOCK_STREAM self.local = threading.local() print \"__init__\" def __enter__(self): print \"__enter__\" if hasattr(self.local, 'sock'): raise RuntimeError('Already connected') self.local.sock = socket(self.family, self.type) self.local.sock.connect(self.address) return self.local.sock def __exit__(self, exc_ty, exc_val, tb): print \"__exit__\" self.local.sock.close() del self.local.sockdef test(conn): with conn as s: s.send(b'GET /index.html HTTP/1.0\\r\\n') s.send(b'Host: www.python.org\\r\\n') s.send(b'\\r\\n') resp = b''.join(iter(partial(s.recv, 8192), b'')) print('Got &#123;&#125; bytes'.format(len(resp)))if __name__ == '__main__': conn = LazyConnection(('www.python.org', 80)) t1 = threading.Thread(target=test, args=(conn,)) t2 = threading.Thread(target=test, args=(conn,)) t1.start() t2.start() t1.join() t2.join() 打印的结果 1234567__init____enter____enter__Got 795 bytes__exit__Got 795 bytes__exit__ 源码分析打开python 2.7的源码,thread local 对应的源码在 Python-2.7.11\\Lib\\_threading_local.py thread local 就是下面的继承关系 1object &gt; _localbase &gt; local 如何实现线程独立拥有自己的local仔细看上面的code, LazyConnection 只实例化了一次,也就是说__init__只调用了一次,所以conn对各个线程来说是共享的,为什么下面的 socket 赋值可以做到各个线程拥有独立的sock对象? 1self.local.sock = socket(self.family, self.type) 虽然new 一个 local 实例, 这个实例对于所有线程是共享的,但是真正执行set/get操作的实现在 _patch,这个函数是关键. 12345678910111213141516def _patch(self): key = object.__getattribute__(self, '_local__key') d = current_thread().__dict__.get(key) if d is None: d = &#123;&#125; current_thread().__dict__[key] = d object.__setattr__(self, '__dict__', d) # we have a new instance dict, so call out __init__ if we have # one cls = type(self) if cls.__init__ is not object.__init__: args, kw = object.__getattribute__(self, '_local__args') cls.__init__(self, *args, **kw) else: object.__setattr__(self, '__dict__', d) 先看 if d is not None 的case 1object.__setattr__(self, '__dict__', d) 也就是说 每次set/get的时候，上面这句话改变了 __dict__,他把 current_thread().__dict__.get(key) 赋值给了__dict__, 而对object的set/get 操作，实际也就是对 __dict__的操作. 如何实现lock因为每次都要改变local.dict,必然存在一个问题,就是要锁操作. 下面的代码会构造一个RLock 给 local, 注意,这个rlock是给local的,也就是说所有线程都是用这个rlock来执行锁操作的. 1234567891011121314151617181920class _localbase(object): __slots__ = '_local__key', '_local__args', '_local__lock' def __new__(cls, *args, **kw): self = object.__new__(cls) key = '_local__key', 'thread.local.' + str(id(self)) object.__setattr__(self, '_local__key', key) object.__setattr__(self, '_local__args', (args, kw)) object.__setattr__(self, '_local__lock', RLock()) if (args or kw) and (cls.__init__ is object.__init__): raise TypeError(\"Initialization arguments are not supported\") # We need to create the thread dict in anticipation of # __init__ being called, to make sure we don't call it # again ourselves. dict = object.__getattribute__(self, '__dict__') current_thread().__dict__[key] = dict return self 看下local get操作 ,进入之前acquire,finally 保证了释放 12345678def __getattribute__(self, name): lock = object.__getattribute__(self, '_local__lock') lock.acquire() try: _patch(self) return object.__getattribute__(self, name) finally: lock.release() __slots___localbase 用 __slots__ 来限制 local的 instance variables __slots__ 的解释: copy from python org The __slots__ declaration takes a list of instance variables, and reserves space in the instance for exactly these in the instance. When __slots__ is used, other instance variables cannot be assigned to 123456class defaultdict2(dict): __slots__ = ['default'] def __init__(self, default=None): ...(like before)... 1234567891011&gt;&gt;&gt; a = defaultdict2(default=0.0)&gt;&gt;&gt; a[1]0.0&gt;&gt;&gt; a.default = -1&gt;&gt;&gt; a[1]-1&gt;&gt;&gt; a.x1 = 1Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in ?AttributeError: 'defaultdict2' object has no attribute 'x1'&gt;&gt;&gt;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Hexo Usage","date":"2016-12-06T00:54:05.000Z","path":"2016/12/06/hexo_usage/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://superway117.github.io/tags/hexo/"}]}]