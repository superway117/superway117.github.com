[{"title":"Python Package管理","date":"2016-12-09T04:49:52.000Z","path":"2016/12/09/python_package_import/","text":"init.pymodule(包括sub module)目录下面, 在py2.7上面,这个文件是需要的;在3.x上面,这个文件已经不是必须的. __init__是会被在module(submodule)加载之前加载 . __init__可以用来实现下面的功能: 帮用户加载需要的submodule或者符号 123# graphics/formats/__init__.pyfrom . import jpgfrom . import png 这样的话用户只需要下面的语句,就可以得到需要的符号 1import graphics.formats 如何控制 export symbolProblem下面的语句会导致把module里面的所有符号都导出. 1from module import * 这样的做法是不受鼓励的,但是事实上为了方便,我们经常这么干. 从性能或者从安全的角度出发,很多时候我们要控制export的符号 Solution__all__ 可以帮你控制输出的符号 demo123456789# somemodule.pydef spam(): passdef grok(): passblah = 42# Only export 'spam' and 'grok'__all__ = ['spam', 'grok'] 如果你定义了__all__为一个空数组,那么nothing will be exported. AttributeError is raised on import if all contains undefined names. Namespace Packages“namespace package” Essentially, a namespace package is a special kind of package designed for merging different directories of code together under a common namespace links Implicit Namespace Packages","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Python Thread Local","date":"2016-12-06T16:54:05.000Z","path":"2016/12/07/py_thread_local/","text":"Problem如何实现: 保存线程自己的值或者状态,并且这个值对其他线程是不可见 Solutionthread-local storage object 可以用来满足这个需求,thread-local只有当前的线程可见. Sample Code下面的code demo了怎么样使用 thread-local 123456789101112131415161718192021222324252627282930313233343536373839404142from socket import socket, AF_INET, SOCK_STREAMimport threadingfrom functools import partialclass LazyConnection: def __init__(self, address, family=AF_INET, type=SOCK_STREAM): self.address = address self.family = AF_INET self.type = SOCK_STREAM self.local = threading.local() print \"__init__\" def __enter__(self): print \"__enter__\" if hasattr(self.local, 'sock'): raise RuntimeError('Already connected') self.local.sock = socket(self.family, self.type) self.local.sock.connect(self.address) return self.local.sock def __exit__(self, exc_ty, exc_val, tb): print \"__exit__\" self.local.sock.close() del self.local.sockdef test(conn): with conn as s: s.send(b'GET /index.html HTTP/1.0\\r\\n') s.send(b'Host: www.python.org\\r\\n') s.send(b'\\r\\n') resp = b''.join(iter(partial(s.recv, 8192), b'')) print('Got &#123;&#125; bytes'.format(len(resp)))if __name__ == '__main__': conn = LazyConnection(('www.python.org', 80)) t1 = threading.Thread(target=test, args=(conn,)) t2 = threading.Thread(target=test, args=(conn,)) t1.start() t2.start() t1.join() t2.join() 打印的结果 1234567__init____enter____enter__Got 795 bytes__exit__Got 795 bytes__exit__ 源码分析打开python 2.7的源码,thread local 对应的源码在 Python-2.7.11\\Lib_threading_local.py thread local 就是下面的继承关系 1object &gt; _localbase &gt; local 如何实现线程独立拥有自己的local仔细看上面的code, LazyConnection 只实例化了一次,也就是说__init__只调用了一次,所以conn对各个线程来说是共享的,为什么下面的 socket 赋值可以做到各个线程拥有独立的sock对象? 1self.local.sock = socket(self.family, self.type) 虽然new 一个 local 实例, 这个实例对于所有线程是共享的,但是真正执行set/get操作的实现在 _patch,这个函数是关键. 12345678910111213141516def _patch(self): key = object.__getattribute__(self, '_local__key') d = current_thread().__dict__.get(key) if d is None: d = &#123;&#125; current_thread().__dict__[key] = d object.__setattr__(self, '__dict__', d) # we have a new instance dict, so call out __init__ if we have # one cls = type(self) if cls.__init__ is not object.__init__: args, kw = object.__getattribute__(self, '_local__args') cls.__init__(self, *args, **kw) else: object.__setattr__(self, '__dict__', d) 先看 if d is not None 的case 1object.__setattr__(self, '__dict__', d) 也就是说 每次set/get的时候，上面这句话改变了 __dict__,他把 current_thread().__dict__.get(key) 赋值给了__dict__, 而对object的set/get 操作，实际也就是对 __dict__的操作. 如何实现lock因为每次都要改变local.dict,必然存在一个问题,就是要锁操作. 下面的代码会构造一个RLock 给 local, 注意,这个rlock是给local的,也就是说所有线程都是用这个rlock来执行锁操作的. 1234567891011121314151617181920class _localbase(object): __slots__ = '_local__key', '_local__args', '_local__lock' def __new__(cls, *args, **kw): self = object.__new__(cls) key = '_local__key', 'thread.local.' + str(id(self)) object.__setattr__(self, '_local__key', key) object.__setattr__(self, '_local__args', (args, kw)) object.__setattr__(self, '_local__lock', RLock()) if (args or kw) and (cls.__init__ is object.__init__): raise TypeError(\"Initialization arguments are not supported\") # We need to create the thread dict in anticipation of # __init__ being called, to make sure we don't call it # again ourselves. dict = object.__getattribute__(self, '__dict__') current_thread().__dict__[key] = dict return self 看下local get操作 ,进入之前acquire,finally 保证了释放 12345678def __getattribute__(self, name): lock = object.__getattribute__(self, '_local__lock') lock.acquire() try: _patch(self) return object.__getattribute__(self, name) finally: lock.release() __slots___localbase 用 __slots__ 来限制 local的 instance variables __slots__ 的解释: copy from python org The __slots__ declaration takes a list of instance variables, and reserves space in the instance for exactly these in the instance. When __slots__ is used, other instance variables cannot be assigned to 123456class defaultdict2(dict): __slots__ = ['default'] def __init__(self, default=None): ...(like before)... 1234567891011&gt;&gt;&gt; a = defaultdict2(default=0.0)&gt;&gt;&gt; a[1]0.0&gt;&gt;&gt; a.default = -1&gt;&gt;&gt; a[1]-1&gt;&gt;&gt; a.x1 = 1Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in ?AttributeError: 'defaultdict2' object has no attribute 'x1'&gt;&gt;&gt;","tags":[{"name":"python","slug":"python","permalink":"http://superway117.github.io/tags/python/"}]},{"title":"Hexo Usage","date":"2016-12-06T00:54:05.000Z","path":"2016/12/06/hexo_usage/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://superway117.github.io/tags/hexo/"}]}]